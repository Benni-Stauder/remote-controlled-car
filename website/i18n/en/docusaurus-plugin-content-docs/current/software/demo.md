# Demo Simulator Directory
## Overview
The demo folder contains scripts to simulate the behavior of an RC car acting as a UDP client. Therefore, the content of this folder is not part of the actual backend and only serves testing purposes. This enables the possibility to test the entire data communication between backend, frontend, and a simulated car without any additional hardware.


## Files
- UDPClient.py
- VehicleDataSimulator.py

## Running the Simulator
To start the simulated RC car, simply run the Python script within UDPClient.py. As this script uses the same configuration file as the entire backend, no further configurations are necessary.

```bash
python UDPClient.py
```


If the config.json file has not been configured before, please follow these steps:


Retrieve your current IP address using a Windows shell: ipconfig
Replace the IP address for both the server and client within config.json
If unsure, do not make any changes to the frontend, port, or buffer settings. Keep the default values.
Run the simulator by executing the client script in UDPClient.py

## Purpose
The purpose of the demo directory is to provide a simulation that mimics the data typically generated by an RC car. This involves simulating speed and RPM as a dependent tuple of data and taking previously generated values into account to create the impression of acceleration or braking.


Additionally, a UDP client is required to connect to the backend and send the generated data. Therefore, another purpose of this directory is to receive controls and settings from both the frontend and backend. These controls and settings are transferred as a binary stream and must be properly decoded. Using this client, the full decoding and extraction of required data is validated and tested.


This data flow can be described as follows. The client sends the current speed, RPM, and battery percentage of the simulated car to the server (backend). Before being sent, this data is encoded into a predefined sequence of bytes to avoid unnecessary overhead. In return, the client receives the current controls (e.g., steering angle) and frontend settings (e.g., driving mode).